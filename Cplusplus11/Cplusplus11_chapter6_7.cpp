//	----------------------------------------------------
//	Chapter6
//	C++11字符串与数字类型的转换
//		to_string,to_wstring,atoi,atol,atof
//	宽窄字符转换
//		Win_VS - USES_CONVERSION,A2W,W2A MultiByteToWideChar,WideCharToMultiByte
//		C++ - mbstowcs,wcstombs
//		C++11 - wstring_convert,codecvt,locale
//		C - mbrtoc16 mbrtoc32


//	Chapter7
//	final - 限制类不能被继承，或限制虚函数不能被重写
//	override - 显示表明指定的虚函数必须重写，不能重载或忽略，使派生类和基类重写的函数具有相同的签名

//	数据类型的内存对齐就是该数据类型定义的变量的内存地址都是(1,2,4,8...)其中一个值的倍数
//	自然对齐就是数据类型的大小和数据类型的对齐属性值相等
//	32bit-x86的处理器，一个时钟周期可以连续读取4个内存单元的数据，即4字节，提高了CPU访问内存的效率
//		但是，内存对齐导致数据在内存中并不是连续存放的，中间可能会有空白填充，特别是自定义的数据类型
//		结构体类型理想的内存对齐是成员中最大内存对齐的整数倍;同时，在限制结构体的内存对齐时，结构体中成员的内存对齐不能超过结构体本身的内存对齐
//	堆内存一般使用当前平台默认的最大内存对齐属性，若自定义的内存对齐超过默认的内存对齐值，不能直接使用malloc/new直接分配内存，需要借助内存对齐之类的方法
//		如果需要的内存对齐小于默认的内存对齐，仍然使用#pragma pack()指定内存对齐值