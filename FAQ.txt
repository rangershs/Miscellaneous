-----------------------------------------------------------------------------------------------
Q：	空指针与void*的区别

A：	空指针是暂时不使用的指针使其指向nullptr(C++11)，防止误用出现问题。空指针其实指向了具体的地址，不过指向的地址在内存中比较小，不允许存放数据和不允许程序访问
	void*型指针指向的内存是可以存放数据的，也是允许程序访问的，不过内存中数据的类型暂时不确定，所以先定义为void*型,需要时再强制转换为相应的数据类型(reinterpret_cast<>())
-----------------------------------------------------------------------------------------------
Q:	DLL中的extern C/.def/__stdcall

A:	(1)	C++标准对函数Name-Mangling没有规定方案，为了解决重载还会给函数名添加一些标识符，而C标准规定了函数编译后命名的规范，
	extertn C的作用是告诉C++编译器以C标准方式对函数命名，链接时能正确找到调用的函数
	(2)	影响函数符号名的因素有C++与C语言的不同、编译器的种类、函数的调用方式(__stdcall、__cdecl[Default])
	(3)	DLL中的函数被调用时以函数名或函数编号的方式索引的，若导出函数使用extern C & __cdecl的方式，那么函数不需要重命名；若
	导出函数使用extern C & __stdcall方式，那么函数需要重命名，因为__stdcall调用方式会对函数名修饰
	(4)	[Recommended] 
					  函数重命名的方式，可以采用.def文件，但它只对dll有用，对.lib里的函数名称不起作用
					  .def文件指定导出的函数，同时指定导出函数的名字
					  使用.def文件，显示调用时导出函数可以不再添加extern C、__declspec(dllexport)声明，__stdcall不能省略，但如果dll是隐式调用，提供的.h文件中仍然
		需要extern C、__declsepc(dllexport)、__stdcall
					  若编译链接时找不到.def文件，在链接选项中指定.def文件名
	(5)	函数调用方式 __stdcall __cdecl
		__cdecl VC默认的函数调用方式，若生成dll只提供给C/C++程序使用，那么采用默认的方式即可，由函数调用者处理函数的压栈与出栈
		__stdcall VC允许指定函数的调用方式，C/C++编写的dll可以提供给其他语言使用，但它会导致函数名称的改变，并且dll提供者和调用者
		需要遵守相同的调用约定，由函数自身处理压栈与出栈
-----------------------------------------------------------------------------------------------
Q:	git 工作区 暂存区 版本库

A:	git status						--	当前的工作状态
	git diff						--	工作区和暂存区的区别
	git diff --staged				--	暂存区和版本库的区别
	git diff HEAD					--	工作区和版本库的区别

	git checkout --file				--	暂存区覆盖工作区指定内容
	git checkout HEAD --file		--	版本库替换工作区和暂存区指定内容
	git reset HEAD					--	版本库覆盖暂存区指定内容
-----------------------------------------------------------------------------------------------
Q:	C++ friend 细节

A:	借助friend关键字，其他函数和类允许访问当前类中的所有成员，但是，友元函数不同于类的成员函数，不能直接访问类中的成员变量，必须通过对象访问
	类的成员函数调用时会隐式地增加this指针指向调用它的对象，从而使用该对象的成员，而友元函数非成员函数，没有this指针，因此在使用类中成员时必须指定具体的对象

	友元关系是单向的，友元关系不具有传递性
	通常不声明友元类，而只是将其中的成员函数(class::func)声明为友元函数，控制类的作用范围
-----------------------------------------------------------------------------------------------
Q:	Funtor

A:	仿函数又称函数对象，即类的实例，可以像使用函数一样使用它，其行为是通过在类中重载()实现的，STL中大量使用
	仿函数可以拥有自己的成员变量和成员函数，即它拥有状态，很多行为在编译期就已经确定了

	C++11推出的Lambda简化了Funtor的使用，在很多情况下完全可以替代Functor
	但是，Lambda捕获的状态受限于局部作用域，若是全局作用范围，仍然使用仿函数或函数
-----------------------------------------------------------------------------------------------
Q:	typeid

A:	typeid(type)
	typeid(expression)

	返回std::type_info对象的引用，调用std::type_info.name()获取类型
	type or expression的cv属性会被忽略
	如果在多态情况下使用，typeid在运行时获取对象的动态类型；其他情况，typeid在编译期获取对象的静态类型
-----------------------------------------------------------------------------------------------
Q:	std::mutex & std::recursive_mutex

A:	递归锁相对于互斥锁而言，允许同一个线程多次加锁，但是须确保解锁与加锁的次数是一致的。在多数情况下，递归锁可以有效防止死锁的发生
	但是，使用递归锁会牺牲一定的效率，更加可怕的是，若使用递归锁后仍然发生了死锁，那么死锁的定位将变得异常困难。而互斥锁发生死锁后，通过调试可以容易地找到死锁发生的位置
-----------------------------------------------------------------------------------------------
Q:	exe <--> dll 传递对象
A:	exe与dll、dll与dll之间以二进制形式传递数据，不同编译器编译同一class对象的二进制码不同、即使同一编译器以不同编译选项（/MT /MD）编译同一class对象的二进制码也是不一样的
	因此跨dll传递class对象（尤其是STL）是不安全的，通常以接口的方式交互	[已验证]

	若以指针的方式传递对象的地址，并且对象是new出来的，那么在/MD选项下正常，而在/MT选项下则会异常，这是因为链接不同RunTimeLibrary导致的（
	https://msdn.microsoft.com/zh-cn/library/ms235460.aspx	）。对于/MT编译选项，在Windows操作环境下可以选择VirtualAlloc/VirtualFree生成/释放内存，那么传递new出来的
	对象就不会出现异常（http://qiusuoge.com/11937.html）	[未验证]
-----------------------------------------------------------------------------------------------
Q:	函数参数 ->	值传递、指针传递、指针的指针传递(指针的引用)、引用传递
A：	可参考	https://blog.csdn.net/u013687632/article/details/78616495

	值传递，拷贝的是参数的副本，不会把影响扩展到函数外部
	引用传递，传递的就是参数本身，在函数内部对其任何操作都会反映到函数外
	指针类型不是特殊的类型，在处理方式上与基本数据类型无异。传递指针类型时，若是对指针本身的操作，不会影响指针指向的内存，只有对指针指向内存的操作才会改变内存中的数据